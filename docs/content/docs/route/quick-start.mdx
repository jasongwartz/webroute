---
title: Quick Start
---

import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Callout } from 'fumadocs-ui/components/callout';

## Install

<Tabs items={["npm", "pnpm", "yarn", "bun"]} defaultIndex={0}>
  <Tab value="npm">
		```
		npm install @webroute/route
		```
	</Tab>
  <Tab value="pnpm">
		```
		pnpm install @webroute/route
		```
	</Tab>
  <Tab value="yarn">
		```
		yarn add @webroute/route
		```
	</Tab>
  <Tab value="bun">
		```
		bun add @webroute/route
		```
	</Tab>
</Tabs>


## Create a Route

In this example, we will create a `GET /posts/:id` endpoint which validates and parses path params, and automatically serialises the response as json.

```ts
const PostRoute = route("/posts/:id")
						.params(/** Define a param validator */)
						.handle(/** Handle the request*/)
```

We might implement this like so

```ts twoslash
import { route } from "@webroute/route"
// ---cut-start---
import { z } from "zod"
type Post = { id:number, name:string, authorId:number }
const getPostFromDb = async (id:number): Promise<Post> => {
	return { id: 1, name: "", authorId: 2 }
}
// ---cut-end---

const PostRoute = route("/posts/:id")
					.params(z.object({ id: z.number() }))
					.handle(async (req, { parse }) => {
						// Validate and parse the params
						const { params } = await parse()
						//      ^?


						const post = await getPostFromDb(params.id)

						return post
					})

```

The resulting route is a standard web request handler and works in any web-standard environment.

```ts
const response = await PostRoute(new Request("https://myapi.com/posts/123"))
```

## Add Middleware

As applications grow, we often want to use middleware to handle the flow of requests or add state to our request. We can achieve this using the `.use` method.

```ts twoslash
// ---cut-start---
import { route } from "@webroute/route"
import { z } from "zod"
type Post = { id:number, name:string, authorId:number }
const getPostFromDb = async (id:number): Promise<Post> => {
	return { id: 1, name: "", authorId: 2 }
}
declare const isAuthed: (req: Request) => Promise<boolean>;
// ---cut-end---
const authedRoute = route().use(req => {
	if(!isAuthed(req)) {
		return Response.json({ code: "UNAUTHORIZED" }, { status: 401 })
	}
})
```

Now we could reuse the base route for any of our authed routes. If we wanted to make our post route an authed route, we could easily do so. 


```ts
const postRoute = authedRoute.path("/posts/:id")
					.params(z.object({ id: z.number() }))
					.handle(async (req, { parse }) => {
						const { id } = await parse("params")
						const post = await getPostFromDb(id)
						return post
					})
```

This approach is helpful because it makes it very clear what middleware runs prior to this route handler.

## Next Steps

- Learn about setting up [Routing](./guides/routing)
- Register [Middleware](./guides/middleware) directly to routers
- Learn about [Route Composition](./guides/composition)
- Integrate with existing apps, frameworks, runtimes in [Building Apps](./guides/building-apps)