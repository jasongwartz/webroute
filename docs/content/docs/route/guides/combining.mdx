---
title: Combining Packages
---

import { Callout } from "fumadocs-ui/components/callout"
import { Accordions, Accordion } from "fumadocs-ui/components/accordion"

The various `webroute` packages are designed to be useful by themselves and are decoupled from any particular framework or approach.

With that said, the packages are also designed to work well together and several helpers are provided so they "talk to eachother" better.

## Integrating `route` with...

The most common interaction is between `route` and other packages.

<Accordions>
<Accordion title="Prerequisite: Collection routes">
Webroute encourages grouping all your app routes into a flat record, when applicable. This shape is used by various utilities as an input.

```ts
export const appRoutes = {
	myRoute, // Object keys don't matter
	postRoute,
	anotherRoute
}
```

<Callout title="Keys don't matter">
The keys in this object (currently) do not matter at all. Records are used over arrays as TypeScript inference is much more performant and scalable with records/objects over arrays.
</Callout>
</Accordion>
</Accordions>


### ...with Client

To convert our routes record into a client-compatible shape, we can use the `ToClient` helper.

```ts
import { ToClient } from "@webroute/core"

export type AppDef = ToClient.InferApp<typeof appRoutes>;
```

We can then import this `AppDef` on the client side and use it with `@webroute/client`.

### ...with Middleware

We can define middleware that is compatible with `route` via the `@webroute/middleware` package.

```ts
import { defineMiddleware } from "@webroute/middleware"

const myMiddleware = defineMiddleware(() => {/**...*/})

route().use(myMiddleware)
```

### ...with Router

We can use `route`s with `@webroute/router` by registering routes.

```ts
import { createRadixRouter } from "@webroute/router"

const router = createRadixRouter([{path: "/foo", methods: ["GET"], payload: myRoute }])
```